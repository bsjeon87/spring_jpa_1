
엔티티 설계 시 주의점.

- 엔티티는 가급적 setter를 사용하지 말자.
(유지보수 어려움.)
- ** 모든 연관관계는 지연로딩으로 설정. => 필요시 fetch join / 엔티티 그래프 기능 사용.
  (OneToMany / ManyToMany / OneToOne 별로 fetch전략이 다름. => 명시적으로 fetch = FetchType.LAZY를  적용하자..)
- 컬렉션은 필드에서 초기화할것.
   (null exception 피하기위해
   / ****하이버네이트의 경우 영속성 컨텍스트에 들어갈때 컬렉션을 하이버네이트에서 래핑하는 클래스로 변경함.
    =>만약 하이버네이트가 변경을 해두었는데, 재 생성하거나 셋하면 제대로 운용되지 않을 수 있음.)

구현 요구사항
회원 기능
- 회원 등록/ 조회
상품 기능
- 상품 등록/상품 수정/ 상품 조회
 주문 기능
- 상품 주문/주문 내역 죄회/ 주문 취소

* 예제 단순화를 위해 구현 X
(로그인과 권한 관리 / 파라미터 검증과 예외처리 단순화 /
 상품은 도서만 사용 / 카테고리는 사용X / 배송 정보는 사용X )

* 애플리케이션 아키텍쳐
계층형 구조사용.
Controller -> Service -> Repository -> DB
    |            |          |
    |            |          |
              Domain
controller, web : 웹 계층. ( service / respository로 바로 단반향 접근도 가능하도록 함(단순한부분을 굳이 service를 거치지않게). -> 유연하게..)
service: 비즈니스 로직, 트랜잭션 처리
repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
domain:엔티티가 모여있는 계층, 모든 계층에서 사용.

각 도메인 별 개발순서: 엔티티, 서비스, 리포지토리 계층을 개발, 테스트케이스를 작성해서 검증,
전체 개발 순서: 회원 도메인 개발 -> 상품도메인 개발 -> 주문 도메인 개발 -> 웹계층 개발 -> API 개발 기본 -> API 개발 고급

*회원 도메인 개발
- 구현기능 => 회원 등록 / 목록 조회

* 순서
- 회원 엔티티 -> 리포지토리 개발 -> 서비스개발 -> 기능테스트.

* 회원 기능 테스트
테스트 요구사항
- 회원가입을 성공해야 한다.
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야한다.

* 상품 도메인 개발
- 구현기능 : 상품등록, 상품 목록 조회, 상품 수정.
- 순서: 상품 엔티티 개발(비즈니스 로직 추가) -> 상품 리포지토리 개발 -> 상품 서비스 개발 -> 상품 기능 테스트.

*도메인 주도 설계 => 비즈니스 로직을 엔티티에 추가.(데이터를 가지고 있는 쪽에 비즈니스 로직이 들어가는것이 가장 좋음.=> 응집력이 있음.)
               => setter를 사용하기 보다는 비즈니스 로직과 관련된 이름을 써서 사용하도록 하는게 좋음.

*** 주문 도메인 개발(핵심) ***
- 구현 기능 : 상품 주문 / 주문 내역 조회 / 주문 취소
- 순서: 주문 엔티티, 주문상품 엔티티 개발 / 주문 리포지토리 개발 / 주문 서비스 개발 /주문 검색 기능 개발 / 주문 기능 테스트

**** (jpa/orm를 활용하면 service단에서 비즈니스 로직에 집중할수 있는 환경을 만들어줌..)
- 비즈니스 로직이 대부분 엔티티에 핵심비즈니스 로직이 있음.(도메인 모델 패턴)
=> 서비스 계층은 필요한 요청을 위임하는 역할을 한다. / 객체지향의 특성을 적극 활용.
- 반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 비즈니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 함.
=> 일반적으로 sql을 다룰때(mybatis jdbc , etc) 사용하는 방법

-- 때로는 트랜잭션 스크립트 패턴이 유지 보수가 좋을 수 있으므로 상황에 따라 선택해서 사용하는게 좋음.(문맥에 따라..)
  (한프로젝트 내에서도 양립할 수 있음. )

- 주문 검색 기능 구현(회원별 / 주문 상태별) => 동적쿼리 사용해야함.
* querydsl을 위한 설정 ->
 build.gradle 설정(plugin 및 build script /etc) -> gradle탭에서 -> Tasks-> other->compileQuerydsl 실행
 (build 폴더에 generated 폴더아래에 Qclass들이 생성됨.)
 ( 코드 asistance + 컴파일 에러 + jpql과 거의 1대1매칭 장점을 가짐(직관적)=>JPQL을 잘알면 금방 배움.)
 **JPA 애플리케이션을 개발할때 선택이 아닌 필수임.

==============================
* 웹 계층 개발

순서
홈화면 레이아웃 -> 회원등록 -> 회원 목록 조회 -> 상품 등록 -> 상품 목록 -> 상품 수정
-> 변경 감지와 병합(merge) -> 상품 주문 -> 주문 목록 검색 / 취소.

thymleaf -> layout(thymeleaf.org/doc/articles/layouts.html
* include-style layouts (현재 예제) -> 여러 html에서 코드 중복이 될 수 있음. <div th:replace="fragments/bodyHeader :: bodyHeader" />
* Hierarchical-style layouts -> 여러 html에 공통적으로 적용할수있도록해서 include 코드 중복이 없음.

*getbootstrap.com 에서 다운로드.

-----
(NotEmpty - spring boot 2.3부터는 javax.validation.constraints를 사용하기 위해서는 'org.springframework.boot:spring-boot-starter-validation' 추가해야함.
* 회원 가입. -> 회원 목록 조회

*요구사항이 간단할때는 Form입력을 받는 객체를 entity그대로 사용해도되나,
복잡해지면, entity에 필요없는 코드나 필드가 추가되어 핵심비즈니스 로직외에 화면과관련된 정보들이 포함됨.
Form의 Input을 위한 객체 생성(MemberForm). / DTO(Data Transfer Object)를 생성하여 렌더링할때 넘겨주기도함.
( ex: Member -> MemberForm )
API를 만들때는 절대 entity를 외부로 반환하면 안됨. API는 spec이기때문에 변경되면 안됨.
추 후 entity에 로직이 변경되었을때 API Spec도 변경되므로.

* 상품 수정( 수정 => jpa 변경감지 이용)
준영속 상태란? 예를 들어 상품 수정 시점에 객체를 새로 생성(함수 updateItem) 하는데, 이 객체(id를 가짐)를 준영속성 엔티티라고 함.
db id를 가지지만, jpa의 영속성컨텍스트에서 관리는 하지 않는 상태임. (book객체)
=> save 시점에 단순히 em.persist를 하려고 하면, 동일한 id가 이미 영속성 컨텍스트에 있으므로 에러가나게됨.(detached entity passed to persist)
 ( 실제 find와 같은 쿼리를 사용하여 jpa로 부터 받은 객체 혹은 id가 null인상태로 persist를 하는 객체를 제외한 경우
   모두 준영속 객체임( 생성된 객체에 임의로 실제 db에있는 id를 넣는 경우도 jpa에서는 deteach된 객체로 여김.)

*** 컨트롤러에서 entity를 생성하지 않는게 좋음
(트랜잭션이 있는 서비스계층에 식별자(id)와 변경할 데이터를 명확하게 전달하여 처리 - dirty 자동 감지 처리하기 자연스러움).
=> itemService.updateItem(itemId, name, price); // service쪽으로 위임.
=> 파라미터가 복잡하다면 DTO(Data transfer object)를 이용하여 service쪽에 파라미터로 넘겨 위임 처리.

준영속 엔티티를 수정하는 2가지 방법.
- 변경 감지 기능 사용.(이게 정석임.)
    ItemService에서..
    @Transactional //자동 변경 감지에 의해 업데이트됨(dirty check).
    public Item updateItem(Long itemId, Book bookParam) {
        Item findItem = itemRepository.findOne(itemId);
        findItem.changeItemPriceStock(bookParam.getPrice(), bookParam.getStock());
        return findItem;
    }

- 병합(merge) 이용. => em.merge도 위에 코드처럼 내부적으로 변경 감지기능 사용. 약간의 차이가 있음. (merge는 더 위험하므로 안쓰는게 좋음.)
    public void save(Item item) {
        if (item.getId() == null) {
            em.persist(item);
        } else {
            Item mergedItem = em.merge(item); //update와 유사. (merged Item이 영속성 컨텍스트에서 관리함. 인자로 들어온 item은 영속객체는 아님.
                                              //merge 기능의 경우 모든 필드를 인자로 넘어온 item 필드로 변경함. (merge안쓰는게 좋음.)
        }
    }

** 상품 주문
---------------------------------------------API---------------------------------

최신 트렌드
-> 템플릿 엔진을 이용해서 렌더링하여 클라이언트에 전달했던 기존 방식에서 SPA(Single page Application) framework(react/veuJs 등)
을가지고 개발함.
-> 마이크로 서비스 아키텍쳐로 가면서 서버끼리 API통신을 함.

* postman 설치. <- API 테스트를 위한 클라이언트

컨트롤러 패키지 분리 -> web / api controller분리. (api/web의 경우 공통처리와 관점에 차이가 있어 분리시킴)

** 엔티티 값을 그대로 json형태를 사용하면 안됨 -> 엔티티(도메인)객체의 값을 변경하는 경우 API 스펙이 변경됨.( 엔티티는 많이 쓰이고,
수정가능성이 높음.) => entity를 그대로 쓰지말고 명확한 API용 DTO(data transfer Object)를 만들어서 사용해야함.(개발자 입장에서도 API 스펙을 파악하기 쉬움)


RESTFull design guide
-> 수정의 경우 put방식이 좋음.( 멱등(여러번해도 동일결과.) 한 특성..)?

개발 정책
-> 객체관점에서도 sql관점에 command( update/insert/delete )와 query(select)를 분리.
   (entity 변경 api는 변경만 하고 변경된 객체 결과를 return하지 않음. 리턴 객체를 하게되면 query기능까지 포함되게 됨.)

API Spec = DTO (최대한 적게 노출하는게 좋음.)

--------------------------------------------------------------------------
지연로딩과 조회 성능 최적화
주문 + 배송정보 + 회원을 조회하는 API를 제작.
****1000프로 이해하고 실무에 사용해야함.

양방향 관계의 경우는 무한루프에 빠짐. (jsonIgnore을 한쪽에 설정해야함.)
Entity를 그대로 노출 시 Lazy 로딩의 경우 null 로 변경되는것을 고려해야함.
=> 이걸 관리하기위해서는

방법 1. hibernate5Module과 같은걸 사용해서 강제 로딩(DB접근)해야하는데,
성능 이슈가 생길수 있음.(사용하지 않는 지연로딩 데이터까지 다 끌어 올수 있음.)

방법 2. 강제로 lazy loading함. 강제로 필요한 객체들의 함수를 초뤃하여 로딩하도록함.

근본적으로 Entity를 그대로 노출해서 생긴 문제이며, API Spec에 많은 정보가  노출 되게 되어
스펙이 추후 변경될 여지가 많음. => DTO를 설정해야함.

-----
fetch join 과 join 사이에는 우열을 가리기 힘듬.
트레이드 오프가 있음.
ex)
 => v3는 order를 가지고 올때 내부 정보를 변경하지 않고 필요한걸 가지고 오기때문에 재사용성이 있음.
 => v4는 특화된 dto에 fit하게 만들어 v3보다 딱딱하고 재활용성이 떨어짐.(성능이 약간 더 좋음. -> 최적화 여부에 대한 고민후 결정하면됨.
 -> repository의 의무는 엔티티 조회의 로직만 제공해야함( db에 의존적인 로직만 제공해야함. )
 -> v4는 repository에 api spec과 관련된 내용이 들어가 repository의 로직 계층과 맞지 않음. api에 의존적인 로직(presentation 로직).  로직의 범용적 활용도가 떨어짐. )
 -> 책임을  나누기 위해서 repository 패키지 밑에 order.simplequery 패키지를 별도로 만들어 별도로 모아 관리.
    (ex: OrderSimpleQueryRepository. => api 의존로직을 별도 패키지에 분리 관리)

*** 쿼리 방식 선택 권장 순서
1. 우선  엔티티를 DTO로 변환하는 방법 선택
2. 필요하면 패치 조인으로 성능 최적화 -> 대부분 성능 이슈 해결됨
3. 그래도 안되면 DTO로 직접 조회하는 방법 사용.
4. 최후에 방버은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template를 사용해서 SQL직접 사용.

----------------------------------------

*gradle
- api(compile) 수정된 클래스에 직 간접적으로 의존하는 것들을 모두 재컴파일 ( 간접 참조하는것들의 api들도 노출되므로.)
- implementation 수정된 클래스에 직접의존하는 것들만 재컴파일(직접 참조하는 api만 노출)
- runtimeonly runtime시점에만 사용.


** 웹 기본
웹서버(아파치) - 정적페이지처리
웹컨테이너(톰캣) - servelet , jsp등을 수행시킬수있는 컨테이너.
WAS( 웹서버 + 웹컨테이너) => 아파치 톰캣(아파치 + 톰캣).

클라이언트가 웹서버에 요청하면 웹서버는 그 요청을 톰캣과 같은 웹 애플리케이션 서버에 위임.
애플리케이션 서버는 요청에 해당하는 서블릿을 실행함.

- 톰캣에서 수행시키는 웹 애플리케이션 구조
  - 웹애플리케이션 이름 (애플리케이션의 루트 디렉토리, html,jsp등이 저장될수있음.)
   -- WEB-INF (애플리케이션의 루트 디렉토리
      --- classes (웹 애플리케이션이 수행하는 서블릿과 드른 일반 클래스들이 위치하는곳.)
      --- lib (동적으로 필요한 라이브러리?들 저장) etc: jdbc 드라이버
      --- web.xml ( 클라이언트의 요청과 서블릿 매핑정보 등이 저장되어있음. )
(개발 완료 후 war압축파일로 만들어 운영서버에 업로드하고, tomcat.exe를 다시실행하면, ware파일의 압축ㅎ이 해제됨과 동시에
자동으로 등록되어 웹 애플리케이션이 실행됨.)

웹 어플리케이션을 컨텍스트(Context)라고함.
 ==> 톰캣 루트 디렉터리의 하위 디렉토리인 webapps 폴더에 작성한 웹 애플리케이션을 위치시킨 다음 톰캣을 껏다가 다시 실행하면,
  톰캣이 자동으로 웹애플리케이션을 인식한 후 실행시킴.( 다른방법은 임의장소에 위치해있는 웹 애플리케이션을 톰캣 설정파일인 server.xml에 등록해서 실행.)

커넥션 풀
- DBMS에  접근하는 connectionPool을 만들어 놓음.
- 생성된 커넥션 객체는 응용프로그램(서블릿)에서 db접근 시 호출해서 연동하여 접근함.

서블릿 실행 구조.
-> 클라이언트가 요청을 하였을때, 매칭된 서블릿의 상태를 확인함.
ex:
--> 클라이언트 1이 localhost:8080/pro/first 로 요청 mapping되어 있는 FirstServlet이 메모리에 존재하는지 확인
--> 로드되어 있지 않으므로, FirstServlet을 메모리에 로딩시키고 init()를 호출함.
--> 클라이언트 1의 요청 처리를 함(doGet or doPost etc)
--> 클라이언트 2가 동일하게 요청을 하였다면, 다시 FirstServlet이 메모리에 존재하는지 확인
--> 클라이언트1이 요청하여 메모리에 올라와 있으므로 바로 요청 처리(doGet or doPost)

톰캣은 서블릿 켄테이너(서블릿 관리)/ 스프링은 경량 컨테이너(스프링이 권한을 가지고 빈(클래스 객체)를 관리)
스프링은 DispatcherServlet를 통해 클라이언트의 요청을 전달받음.

--
모델 1 개발방식( jsp/servlet(뷰+로직) <-> dao <-> db )
모델 2 개발방식( 요청처리(서블릿) <->로직처리(model) <-> db )          => MVC
                 |
               jsp or html(view)

----------------------------------------
일대다 조회 (Collection 조회 최적화)
(ex: 1 - 3 관계인경우 1인 걸 이용해서 조회하게되면 DB입장에서 3줄로 만들어 조회가됨)
(예에서는 Order - OrderItem 관계)
