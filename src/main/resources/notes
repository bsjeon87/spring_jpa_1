
엔티티 설계 시 주의점.

- 엔티티는 가급적 setter를 사용하지 말자.
(유지보수 어려움.)
- ** 모든 연관관계는 지연로딩으로 설정. => 필요시 fetch join / 엔티티 그래프 기능 사용.
  (OneToMany / ManyToMany / OneToOne 별로 fetch전략이 다름. => 명시적으로 fetch = FetchType.LAZY를  적용하자..)
- 컬렉션은 필드에서 초기화할것.
   (null exception 피하기위해
   / ****하이버네이트의 경우 영속성 컨텍스트에 들어갈때 컬렉션을 하이버네이트에서 래핑하는 클래스로 변경함.
    =>만약 하이버네이트가 변경을 해두었는데, 재 생성하거나 셋하면 제대로 운용되지 않을 수 있음.)

구현 요구사항
회원 기능
- 회원 등록/ 조회
상품 기능
- 상품 등록/상품 수정/ 상품 조회
 주문 기능
- 상품 주문/주문 내역 죄회/ 주문 취소

* 예제 단순화를 위해 구현 X
(로그인과 권한 관리 / 파라미터 검증과 예외처리 단순화 /
 상품은 도서만 사용 / 카테고리는 사용X / 배송 정보는 사용X )

* 애플리케이션 아키텍쳐
계층형 구조사용.
Controller -> Service -> Repository -> DB
    |            |          |
    |            |          |
              Domain
controller, web : 웹 계층. ( service / respository로 바로 단반향 접근도 가능하도록 함(단순한부분을 굳이 service를 거치지않게). -> 유연하게..)
service: 비즈니스 로직, 트랜잭션 처리
repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
domain:엔티티가 모여있는 계층, 모든 계층에서 사용.

각 도메인 별 개발순서: 엔티티, 서비스, 리포지토리 계층을 개발, 테스트케이스를 작성해서 검증,
전체 개발 순서: 회원 도메인 개발 -> 상품도메인 개발 -> 주문 도메인 개발 -> 웹계층 개발 -> API 개발 기본 -> API 개발 고급

*회원 도메인 개발
- 구현기능 => 회원 등록 / 목록 조회

* 순서
- 회원 엔티티 -> 리포지토리 개발 -> 서비스개발 -> 기능테스트.

* 회원 기능 테스트
테스트 요구사항
- 회원가입을 성공해야 한다.
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야한다.

* 상품 도메인 개발
- 구현기능 : 상품등록, 상품 목록 조회, 상품 수정.
- 순서: 상품 엔티티 개발(비즈니스 로직 추가) -> 상품 리포지토리 개발 -> 상품 서비스 개발 -> 상품 기능 테스트.

*도메인 주도 설계 => 비즈니스 로직을 엔티티에 추가.(데이터를 가지고 있는 쪽에 비즈니스 로직이 들어가는것이 가장 좋음.=> 응집력이 있음.)
               => setter를 사용하기 보다는 비즈니스 로직과 관련된 이름을 써서 사용하도록 하는게 좋음.

*** 주문 도메인 개발(핵심) ***
- 구현 기능 : 상품 주문 / 주문 내역 조회 / 주문 취소
- 순서: 주문 엔티티, 주문상품 엔티티 개발 / 주문 리포지토리 개발 / 주문 서비스 개발 /주문 검색 기능 개발 / 주문 기능 테스트

**** (jpa/orm를 활용하면 service단에서 비즈니스 로직에 집중할수 있는 환경을 만들어줌..)
- 비즈니스 로직이 대부분 엔티티에 핵심비즈니스 로직이 있음.(도메인 모델 패턴)
=> 서비스 계층은 필요한 요청을 위임하는 역할을 한다. / 객체지향의 특성을 적극 활용.
- 반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 비즈니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 함.
=> 일반적으로 sql을 다룰때(mybatis jdbc , etc) 사용하는 방법

-- 때로는 트랜잭션 스크립트 패턴이 유지 보수가 좋을 수 있으므로 상황에 따라 선택해서 사용하는게 좋음.(문맥에 따라..)
  (한프로젝트 내에서도 양립할 수 있음. )

- 주문 검색 기능 구현(회원별 / 주문 상태별) => 동적쿼리 사용해야함.
* querydsl을 위한 설정 ->
 build.gradle 설정(plugin 및 build script /etc) -> gradle탭에서 -> Tasks-> other->compileQuerydsl 실행
 (build 폴더에 generated 폴더아래에 Qclass들이 생성됨.)
 ( 코드 asistance + 컴파일 에러 + jpql과 거의 1대1매칭 장점을 가짐(직관적)=>JPQL을 잘알면 금방 배움.)
 **JPA 애플리케이션을 개발할때 선택이 아닌 필수임.

==============================
* 웹 계층 개발

순서
홈화면 레이아웃 -> 회원등록 -> 회원 목록 조회 -> 상품 등록 -> 상품 목록 -> 상품 수정
-> 변경 감지와 병합(merge) -> 상품 주문 -> 주문 목록 검색 / 취소.

thymleaf -> layout(thymeleaf.org/doc/articles/layouts.html
* include-style layouts (현재 예제) -> 여러 html에서 코드 중복이 될 수 있음. <div th:replace="fragments/bodyHeader :: bodyHeader" />
* Hierarchical-style layouts -> 여러 html에 공통적으로 적용할수있도록해서 include 코드 중복이 없음.

*getbootstrap.com 에서 다운로드.

-----
(NotEmpty - spring boot 2.3부터는 javax.validation.constraints를 사용하기 위해서는 'org.springframework.boot:spring-boot-starter-validation' 추가해야함.
* 회원 가입. -> 회원 목록 조회

*요구사항이 간단할때는 Form입력을 받는 객체를 entity그대로 사용해도되나,
복잡해지면, entity에 필요없는 코드나 필드가 추가되어 핵심비즈니스 로직외에 화면과관련된 정보들이 포함됨.
Form의 Input을 위한 객체 생성(MemberForm). / DTO(Data Transfer Object)를 생성하여 렌더링할때 넘겨주기도함.
( ex: Member -> MemberForm )
API를 만들때는 절대 entity를 외부로 반환하면 안됨. API는 spec이기때문에 변경되면 안됨.
추 후 entity에 로직이 변경되었을때 API Spec도 변경되므로.

* 상품 수정( 수정 => jpa 변경감지 이용)
준영속 상태란? 예를 들어 상품 수정 시점에 객체를 새로 생성(함수 updateItem) 하는데, 이 객체(id를 가짐)를 준영속성 엔티티라고 함.
db id를 가지지만, jpa의 영속성컨텍스트에서 관리는 하지 않는 상태임. (book객체)
=> save 시점에 단순히 em.persist를 하려고 하면, 동일한 id가 이미 영속성 컨텍스트에 있으므로 에러가나게됨.(detached entity passed to persist)
 ( 실제 find와 같은 쿼리를 사용하여 jpa로 부터 받은 객체 혹은 id가 null인상태로 persist를 하는 객체를 제외한 경우
   모두 준영속 객체임( 생성된 객체에 임의로 실제 db에있는 id를 넣는 경우도 jpa에서는 deteach된 객체로 여김.)

*** 컨트롤러에서 entity를 생성하지 않는게 좋음
(트랜잭션이 있는 서비스계층에 식별자(id)와 변경할 데이터를 명확하게 전달하여 처리 - dirty 자동 감지 처리하기 자연스러움).
=> itemService.updateItem(itemId, name, price); // service쪽으로 위임.
=> 파라미터가 복잡하다면 DTO(Data transfer object)를 이용하여 service쪽에 파라미터로 넘겨 위임 처리.

준영속 엔티티를 수정하는 2가지 방법.
- 변경 감지 기능 사용.(이게 정석임.)
    ItemService에서..
    @Transactional //자동 변경 감지에 의해 업데이트됨(dirty check).
    public Item updateItem(Long itemId, Book bookParam) {
        Item findItem = itemRepository.findOne(itemId);
        findItem.changeItemPriceStock(bookParam.getPrice(), bookParam.getStock());
        return findItem;
    }

- 병합(merge) 이용. => em.merge도 위에 코드처럼 내부적으로 변경 감지기능 사용. 약간의 차이가 있음. (merge는 더 위험하므로 안쓰는게 좋음.)
    public void save(Item item) {
        if (item.getId() == null) {
            em.persist(item);
        } else {
            Item mergedItem = em.merge(item); //update와 유사. (merged Item이 영속성 컨텍스트에서 관리함. 인자로 들어온 item은 영속객체는 아님.
                                              //merge 기능의 경우 모든 필드를 인자로 넘어온 item 필드로 변경함. (merge안쓰는게 좋음.)
        }
    }

** 상품 주문
---------------------------------------------API---------------------------------

최신 트렌드
-> 템플릿 엔진을 이용해서 렌더링하여 클라이언트에 전달했던 기존 방식에서 SPA(Single page Application) framework(react/veuJs 등)
을가지고 개발함.
-> 마이크로 서비스 아키텍쳐로 가면서 서버끼리 API통신을 함.

* postman 설치. <- API 테스트를 위한 클라이언트

컨트롤러 패키지 분리 -> web / api controller분리. (api/web의 경우 공통처리와 관점에 차이가 있어 분리시킴)

** 엔티티 값을 그대로 json형태를 사용하면 안됨 -> 엔티티(도메인)객체의 값을 변경하는 경우 API 스펙이 변경됨.( 엔티티는 많이 쓰이고,
수정가능성이 높음.) => entity를 그대로 쓰지말고 명확한 API용 DTO(data transfer Object)를 만들어서 사용해야함.(개발자 입장에서도 API 스펙을 파악하기 쉬움)


RESTFull design guide
-> 수정의 경우 put방식이 좋음.( 멱등(여러번해도 동일결과.) 한 특성..)?

개발 정책
-> 객체관점에서도 sql관점에 command( update/insert/delete )와 query(select)를 분리.
   (entity 변경 api는 변경만 하고 변경된 객체 결과를 return하지 않음. 리턴 객체를 하게되면 query기능까지 포함되게 됨.)

API Spec = DTO (최대한 적게 노출하는게 좋음.)

--------------------------------------------------------------------------
지연로딩과 조회 성능 최적화
주문 + 배송정보 + 회원을 조회하는 API를 제작.
****1000프로 이해하고 실무에 사용해야함.

양방향 관계의 경우는 무한루프에 빠짐. (jsonIgnore을 한쪽에 설정해야함.)
Entity를 그대로 노출 시 Lazy 로딩의 경우 null 로 변경되는것을 고려해야함.
=> 이걸 관리하기위해서는

방법 1. hibernate5Module과 같은걸 사용해서 강제 로딩(DB접근)해야하는데,
성능 이슈가 생길수 있음.(사용하지 않는 지연로딩 데이터까지 다 끌어 올수 있음.)

방법 2. 강제로 lazy loading함. 강제로 필요한 객체들의 함수를 초뤃하여 로딩하도록함.

근본적으로 Entity를 그대로 노출해서 생긴 문제이며, API Spec에 많은 정보가  노출 되게 되어
스펙이 추후 변경될 여지가 많음. => DTO를 설정해야함.

-----
fetch join 과 join 사이에는 우열을 가리기 힘듬.
트레이드 오프가 있음.
ex)
 => v3는 order를 가지고 올때 내부 정보를 변경하지 않고 필요한걸 가지고 오기때문에 재사용성이 있음.
 => v4는 특화된 dto에 fit하게 만들어 v3보다 딱딱하고 재활용성이 떨어짐.(성능이 약간 더 좋음. -> 최적화 여부에 대한 고민후 결정하면됨.
 -> repository의 의무는 엔티티 조회의 로직만 제공해야함( db에 의존적인 로직만 제공해야함. )
 -> v4는 repository에 api spec과 관련된 내용이 들어가 repository의 로직 계층과 맞지 않음. api에 의존적인 로직(presentation 로직).  로직의 범용적 활용도가 떨어짐. )
 -> 책임을  나누기 위해서 repository 패키지 밑에 order.simplequery 패키지를 별도로 만들어 별도로 모아 관리.
    (ex: OrderSimpleQueryRepository. => api 의존로직을 별도 패키지에 분리 관리)

*** 쿼리 방식 선택 권장 순서
1. 우선  엔티티를 DTO로 변환하는 방법 선택
2. 필요하면 패치 조인으로 성능 최적화 -> 대부분 성능 이슈 해결됨
3. 그래도 안되면 DTO로 직접 조회하는 방법 사용.
4. 최후에 방버은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template를 사용해서 SQL직접 사용.

----------------------------------------

*gradle
- api(compile) 수정된 클래스에 직 간접적으로 의존하는 것들을 모두 재컴파일 ( 간접 참조하는것들의 api들도 노출되므로.)
- implementation 수정된 클래스에 직접의존하는 것들만 재컴파일(직접 참조하는 api만 노출)
- runtimeonly runtime시점에만 사용.


** 웹 기본

java.exe 가 수행될때 프로세서 별로 jvm을 가지고있으며, 독립적인 실행환경이다.
(java.exe tomcat 실행 시 톰캣을 위한 프로세스내에 jvm이 수행됨.)
=> 특수하게 여러 jvm instance가 공유하는 메모리/데이터 자원이 있기는 함.( Class data sharing )
   --> 여러 jvm instance가 loaded된 class를 공유함(shared memory를 통해서 / dll처럼 생각할수 있을듯)->일반적으로 system class들임.

웹서버(아파치) - 정적페이지처리
웹컨테이너(톰캣) - servelet , jsp등을 수행시킬수있는 컨테이너.
WAS( 웹서버 + 웹컨테이너) => 아파치 톰캣(아파치 + 톰캣).

클라이언트가 웹서버에 요청하면 웹서버는 그 요청을 톰캣과 같은 웹 애플리케이션 서버에 위임.
애플리케이션 서버는 요청에 해당하는 서블릿을 실행함.

- 톰캣에서 수행시키는 웹 애플리케이션 구조
  - 웹애플리케이션 이름 (애플리케이션의 루트 디렉토리, html,jsp등이 저장될수있음.)
   -- WEB-INF (애플리케이션의 루트 디렉토리
      --- classes (웹 애플리케이션이 수행하는 서블릿과 드른 일반 클래스들이 위치하는곳.)
      --- lib (동적으로 필요한 라이브러리?들 저장) etc: jdbc 드라이버
      --- web.xml ( 클라이언트의 요청과 서블릿 매핑정보 등이 저장되어있음. )
(개발 완료 후 war압축파일로 만들어 운영서버에 업로드하고, tomcat.exe를 다시실행하면, ware파일의 압축ㅎ이 해제됨과 동시에
자동으로 등록되어 웹 애플리케이션이 실행됨.)

웹 어플리케이션을 컨텍스트(Context)라고함.
 ==> 톰캣 루트 디렉터리의 하위 디렉토리인 webapps 폴더에 작성한 웹 애플리케이션을 위치시킨 다음 톰캣을 껏다가 다시 실행하면,
  톰캣이 자동으로 웹애플리케이션을 인식한 후 실행시킴.( 다른방법은 임의장소에 위치해있는 웹 애플리케이션을 톰캣 설정파일인 server.xml에 등록해서 실행.)

커넥션 풀
- DBMS에  접근하는 connectionPool을 만들어 놓음.
- 생성된 커넥션 객체는 응용프로그램(서블릿)에서 db접근 시 호출해서 연동하여 접근함.

서블릿 실행 구조.( 클라이언트 요청 당 thread 를 생성해서 servlet을 수행하는 컨셉 - 클라이언트 요청당(pid는 동일, thread는 차이가있음.)
-> 클라이언트가 요청을 하였을때, 매칭된 서블릿의 상태를 확인함.
ex:
--> 클라이언트 1이 localhost:8080/pro/first 로 요청 mapping되어 있는 FirstServlet이 메모리에 존재하는지 확인
--> 로드되어 있지 않으므로, FirstServlet을 메모리에 로딩시키고 init()를 호출함.
--> 클라이언트 1의 요청 처리를 함(doGet or doPost etc)
--> 클라이언트 2가 동일하게 요청을 하였다면, 다시 FirstServlet이 메모리에 존재하는지 확인
--> 클라이언트1이 요청하여 메모리에 올라와 있으므로 바로 요청 처리(doGet or doPost)

톰캣은 서블릿 켄테이너(서블릿 관리)/ 스프링은 경량 컨테이너(스프링이 권한을 가지고 빈(클래스 객체)를 관리)
스프링은 DispatcherServlet를 통해 클라이언트의 요청을 전달받음.
------------------------------------------------------------------------------
URI = (URL+URN)
URN => 이름으로 리소스 구분.( 현재 거의사용되지 않음.) => 따라서 URI = URL로 봐도 큰 무리가없음.
-------------------------------------------------------------------
TCP에서 close하여 세션을 닫는게 가능하지만 강제로 랜선 뽑는 경우 문제가됨.
해결을 위해=>
keep alives  (TCP socket option) 사용 시
TCP 전송이 한가한 경우, 주기적으로 세그먼트를 전송 하고 상대가 정상적으로 동작하면 ACK받음.
=> 끊기는 즉시 앱이 알아야하는 경우너무 느림. ( 기본적으로 약 2시간정도가 지나야 알수있음)

Heartbeats
=> UDP를 이용하여,  keep alives를 직접 앱단에서 하는것.
------------------------------------------------------------------------------
HTTP 1/2/3 스펙이 나옴. 2에 많은 기능이들어감.
-----------------------------------------------------------------------------
비연결성/connectionless (기본적으로 HTTP는 비연결모델 => 웹에서는 실시간 처리가 크게 필요없음. ex:웹검색후 자료확인 후 한참뒤 다른  명령처리)
* 연결유지 모델 -> 3 hand shake를 계속 유지( 클라이언트가 연결 후 사용하지 않아도, 자원(소켓)이 소모됨)

* 비연결유지 모델 -> 요청마다 3 hand shake를 함.
=> 성능향상을 위해  HTTP 지속 연결(Persistent connections / 일정시간동안 연결유지)로 문제해결
=> HTTP/2,3에서 더 많은 최적화가됨.
------------------------------------------------------------------------------
* Stateful / Stateless차이( 클라이언트의 상태를 유지시키는지의 차이.) => 대용량 트래픽 대응을 위해서는 stateless 모델로 만들어야함.
** 무상태는 응답 서버를 쉽게 바꿀 수있음.(서버증설이 쉬움 )
 => 로그인한 사용자에 대한 서비스의 경우 무상태처리를 하기힘듬.
    (브라우저 쿠키와 서버 세션등으르 사용해서 상태유지.)

** 상태유지의 경우 항상 같은 서버와 클라이언트가 통신해야함. (정보를 가지고 있어야함.)
** 상태유지방식은 상태를 저장하던 서버가 죽은 경우, 다른 서버와 처음부터 다시해야함.

- stateful(각각의 질문은 각각 다른 점원에게 문의하면 문제있음)
* 고객: 이 노트북 얼마인가요?
* 점원: 100만원입니다. (노트북 상태유지)

* 고객:2개 구매하겠습니다.
* 점원: 200만원입니다. 신용카드 현금중에 어떤걸로 구매하시겠어요? (노트북, 2개 상태유지)

* 고객: 신용카드로 구매하겠습니다.
* 점원: 200만원 결제 완료되었습니다.

- stateless(각각의 질문은 각각 다른 점원에게 문의해도 문제없음)
* 고객: 이 노트북 얼마인가요?
* 점원: 100만원입니다.

* 고객:노트북 2개 구매하겠습니다.
* 점원: 200만원입니다. 신용카드 현금중에 어떤걸로 구매하시겠어요?

* 고객: 노트북 2개 신용카드로 구매하겠습니다.
* 점원: 200만원 결제 완료되었습니다.

------------------------------------------------------------------------------
모델 1 개발방식( jsp/servlet(뷰+로직) <-> dao <-> db )
모델 2 개발방식( 요청처리(서블릿) <->로직처리(model) <-> db )          => MVC
                 |
               jsp or html(view)

---------------------------------------
영속성 관리
-> 스프링부트에서 entitymanager에 대하여 라이프 사이클을 관리함.
( 요청별(thread별)로 entitymanager를 주입하여 코드를 수행하게 되며,
@Transaction을 사용하지 않더라도 close는 thread가 종료되는 시점에 호출되어 지는것으로 보임(?) <- 명확한 확인 필요)
( @Transaction이 있는 경우에는 db데이터 수정/rollback/commit에 대한 em 처리를 자동으로 해주는것임-> close되지 않음..)
----------------------------------------
일대다 조회 (Collection 조회 최적화)
(ex: 1 - 3 관계인경우 1인 걸 이용해서 조회하게되면 DB입장에서 3줄로 만들어 조회가됨)
(예에서는 Order - OrderItem 관계)

*지연로딩될 객체(프록시)는 객체의 id만 로딩되어 있는 상태임. getId를 한다고해서 지연로딩이 일어나지않음.


일대다 -> 패치 조인 사용 시 페이징 불가( 디비에서는 다쪽의 기준으로 데이터가 뻥튀기됨)
      -> 페이징 시도 시 db에서 전체 데이터를 가지고와서 app단에서 처리함(jpa 단)
      한계돌파) => ToOne관계(ManyToOne / OneToOne)는 패치 조인으로 한번에 가지고옴.
                  ToMany관계는 패치 조인을 사용하지 않고, 지연로딩으로 조회함.
                  => 지연로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size 를 설정하여 해당 하는 만큼 가지고 오도록함.
                  => batch_fetch 원리 => jpa에서 db에서 얻어온 정보를 알고 있어서, 특정 객체에 지연로딩이 발생하면, 해당 객체와 동일한
                  클래스의 다른 객체의 지연로딩까지 한번(batch size만큼)에 가지고오는 방식. (예제 참조->findOne을 사용하여 두개의
                  엔티티 객체를 별도로 쿼리한 뒤에 한 객체의 지연로딩을 발생시키면 다른 객체의 지연로딩까지 한번에 처리함)

==============================90프로 최적화 이슈는 위에 설명된 해법으로 해결가능, 나머지 10프로를 위해 아래방법 사용===============================================
DTO 조회방식(v4,5,6)

* JPA에서 컬렉션을 포함한 DTO직접 조회( 패치조인 보다 퍼올리는 데이터를 최적화할수있음.) => 1+N문제는 존재함(order조회후 order개수만큼 돌면서 컬렉션 조회하므로.)
=>1+N문제 해결을 위해 where in 절을 사용하여 올린뒤에 코드를 이용하여 최적화함.
=> 쿼리 한번으로 끌어올린뒤 조합하는 방식 / 페이징 불가 / 상황에 따라 v5(where in 절사용하는 방법)보다 느릴수 있음( 중복 데이터가 많음.)
   (** 애플리케이션에 추가 작업이 큼.)

-------
쿼리 적용 권장 순서
1. 엔티티 조회 방식 으로 우선 접근
 1.1 패치조인으로 쿼리수 최적화
 1.2 컬렉션 최적화
   1.2.1 페이징 필요 defualt_batch_fetch_size 로 최적화
   1.2.2 페이징 필요X -> 페치 조인 사용
2. 엔티티 조회방식으로 해결안되면 DTO조회 방식 사용 V4~V6)
3. DTO조회방식으로도 해결안되면 NativeSQL or 스프링 JdbcTemplate사용.

엔티티 조회를 권장하는 이유.: 엔티티 조회방식은 패치 조인이나, batch_fetch_size를 사용해 코드를 거의 수정하지 않고,
옵션을 약간 변경해서 다양한 성능최적화를 시도할 수 있음. 반면에 DTO를 직접 조회하는 방식은
성능을 최적화하거나 성능 최적화 방식으 ㄹ변경할 때 많은 코드를 변경해야 함.
=> 90프로정도는 커버됨. => 실무에서 커버안된다면 캐쉬(레디스) 도입등의 방법으로 해결하는게 맞는것 같다.(캐쉬할때도 엔티티를 직접 올리면안됨. DTO로 넘겨야함)

------------------
OSIV와 성능 최적화
-Open Session In view:하이버네이트
- Open EntityManager In View: JPA
(관례상 OSIV)

DB connection Pool
-> Connection Pool 매니저가 일정의 Connection을 연결하고 있다가 요청이 들어오면 Connection을 할당해줌.
 클라이언트는 Connection을 다 쓰면 다시 반납하는 구조로 이루어짐. (DB에 연결하는 고자ㅓㅇ은 시간이 많이 소요되는 연산이므로 Pool을 유지)

Connection Pool을 구현하기 위해 spec을 정해놓은 interface => DataSource임(ex:JDBC Driver내에 자체적으로 내장되어 있음.).

영속성 컨텍스트 생존 범위와 관련되어있음 -> 알아야 실무에서 장애없음.
(기본적으로 jpa가 영속성 컨텍스트에 데이터 커넥션을 얻어와야함.
 언제 jpa 데이터 커넥션을 얻어오는가? 데이터 트랜잭션을 시작할때 영속성 컨텍스트가 데이터베이스 커넥션을 가지고옴.
 (Controller까지는 영속가능/수정불가 , Service는 영속가능/수정가능)

springboot는 spring.jpa.open-in-view default on.
 spring.jpa.open-in-view: true / false
 OSIV enable: Service/repository계층에서 처음 db접근 시 pool을 얻어옴(?). .
              service/repository 처리 후 Controller로 return한뒤에도 데이터 커넥션을 유지함.(response가 나간 뒤에 반환함.)
              (controller에서 lazy loading이 가능하도록 하기위해서..)
        * 단점: 너무 오랫동안 database conenction을 물고 있음.(만약 3초동안 잡고있다면, 3초동안 database connection을 반환하지 않음.)
      disable: 트랜잭션을 종료할때( @transaction 이 끝나거나 그외에 @Transaction이 없는 경우 query 처리후 바로???),
               영속성 컨텍스트를 닫고 DB Connection도 반환한다.
               ( 지연로딩도 트랜잭션 안에서 처리해야함. ) / controller나 view에서 엔티티 수정을해도 db반영안됨(exception발생이 일어날수있음).

* disable시 해결을 위한 방법
=> 비즈니스 로직이 아닌 query(view/api)용 query service를 별도로 만듬(dto와 함께)
  ex: OrderService:핵심 비즈니스 로직 / OrderQueryService:화면이나 API에 맞춘 서비스(주로 읽기 전용 트랜잭션 사용)
   =>유지보수관점에서 좋음( 객체지향 관점으로 책임 분리)

고객서비스 기반 트래픽이 많고 실시간 API는 OSIV를 끄고, 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켠다.


