
엔티티 설계 시 주의점.

- 엔티티는 가급적 setter를 사용하지 말자.
(유지보수 어려움.)
- ** 모든 연관관계는 지연로딩으로 설정. => 필요시 fetch join / 엔티티 그래프 기능 사용.
  (OneToMany / ManyToMany / OneToOne 별로 fetch전략이 다름. => 명시적으로 fetch = FetchType.LAZY를  적용하자..)
- 컬렉션은 필드에서 초기화할것.
   (null exception 피하기위해
   / ****하이버네이트의 경우 영속성 컨텍스트에 들어갈때 컬렉션을 하이버네이트에서 래핑하는 클래스로 변경함.
    =>만약 하이버네이트가 변경을 해두었는데, 재 생성하거나 셋하면 제대로 운용되지 않을 수 있음.)

구현 요구사항
회원 기능
- 회원 등록/ 조회
상품 기능
- 상품 등록/상품 수정/ 상품 조회
 주문 기능
- 상품 주문/주문 내역 죄회/ 주문 취소

* 예제 단순화를 위해 구현 X
(로그인과 권한 관리 / 파라미터 검증과 예외처리 단순화 /
 상품은 도서만 사용 / 카테고리는 사용X / 배송 정보는 사용X )

* 애플리케이션 아키텍쳐
계층형 구조사용.
Controller -> Service -> Repository -> DB
    |            |          |
    |            |          |
              Domain
controller, web : 웹 계층. ( service / respository로 바로 단반향 접근도 가능하도록 함(단순한부분을 굳이 service를 거치지않게). -> 유연하게..)
service: 비즈니스 로직, 트랜잭션 처리
repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
domain:엔티티가 모여있는 계층, 모든 계층에서 사용.

각 도메인 별 개발순서: 엔티티, 서비스, 리포지토리 계층을 개발, 테스트케이스를 작성해서 검증,
전체 개발 순서: 회원 도메인 개발 -> 상품도메인 개발 -> 주문 도메인 개발 -> 웹계층 개발 -> API 개발 기본 -> API 개발 고급

*회원 도메인 개발
- 구현기능 => 회원 등록 / 목록 조회

* 순서
- 회원 엔티티 -> 리포지토리 개발 -> 서비스개발 -> 기능테스트.

* 회원 기능 테스트
테스트 요구사항
- 회원가입을 성공해야 한다.
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야한다.

* 상품 도메인 개발
- 구현기능 : 상품등록, 상품 목록 조회, 상품 수정.
- 순서: 상품 엔티티 개발(비즈니스 로직 추가) -> 상품 리포지토리 개발 -> 상품 서비스 개발 -> 상품 기능 테스트.

*도메인 주도 설계 => 비즈니스 로직을 엔티티에 추가.(데이터를 가지고 있는 쪽에 비즈니스 로직이 들어가는것이 가장 좋음.=> 응집력이 있음.)
               => setter를 사용하기 보다는 비즈니스 로직과 관련된 이름을 써서 사용하도록 하는게 좋음.

*** 주문 도메인 개발(핵심) ***
- 구현 기능 : 상품 주문 / 주문 내역 조회 / 주문 취소
- 순서: 주문 엔티티, 주문상품 엔티티 개발 / 주문 리포지토리 개발 / 주문 서비스 개발 /주문 검색 기능 개발 / 주문 기능 테스트

**** (jpa/orm를 활용하면 service단에서 비즈니스 로직에 집중할수 있는 환경을 만들어줌..)
- 비즈니스 로직이 대부분 엔티티에 핵심비즈니스 로직이 있음.(도메인 모델 패턴)
=> 서비스 계층은 필요한 요청을 위임하는 역할을 한다. / 객체지향의 특성을 적극 활용.
- 반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 비즈니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 함.
=> 일반적으로 sql을 다룰때(mybatis jdbc , etc) 사용하는 방법

-- 때로는 트랜잭션 스크립트 패턴이 유지 보수가 좋을 수 있으므로 상황에 따라 선택해서 사용하는게 좋음.(문맥에 따라..)
  (한프로젝트 내에서도 양립할 수 있음. )

- 주문 검색 기능 구현(회원별 / 주문 상태별) => 동적쿼리 사용해야함.
* querydsl을 위한 설정 ->
 build.gradle 설정(plugin 및 build script /etc) -> gradle탭에서 -> Tasks-> other->compileQuerydsl 실행
 (build 폴더에 generated 폴더아래에 Qclass들이 생성됨.)
 ( 코드 asistance + 컴파일 에러 + jpql과 거의 1대1매칭 장점을 가짐(직관적)=>JPQL을 잘알면 금방 배움.)
 **JPA 애플리케이션을 개발할때 선택이 아닌 필수임.

==============================
* 웹 계층 개발

순서
홈화면 레이아웃 -> 회원등록 -> 회원 목록 조회 -> 상품 등록 -> 상품 목록 -> 상품 수정
-> 변경 감지와 병합(merge) -> 상품 주문 -> 주문 목록 검색 / 취소.

thymleaf -> layout(thymeleaf.org/doc/articles/layouts.html
* include-style layouts (현재 예제) -> 여러 html에서 코드 중복이 될 수 있음. <div th:replace="fragments/bodyHeader :: bodyHeader" />
* Hierarchical-style layouts -> 여러 html에 공통적으로 적용할수있도록해서 include 코드 중복이 없음.

*getbootstrap.com 에서 다운로드.

-----
(NotEmpty - spring boot 2.3부터는 javax.validation.constraints를 사용하기 위해서는 'org.springframework.boot:spring-boot-starter-validation' 추가해야함.
* 회원 가입. -> 회원 목록 조회

*요구사항이 간단할때는 Form입력을 받는 객체를 entity그대로 사용해도되나,
복잡해지면, entity에 필요없는 코드나 필드가 추가되어 핵심비즈니스 로직외에 화면과관련된 정보들이 포함됨.
Form의 Input을 위한 객체 생성(MemberForm). / DTO(Data Transfer Object)를 생성하여 렌더링할때 넘겨주기도함.
( ex: Member -> MemberForm )
API를 만들때는 절대 entity를 외부로 반환하면 안됨. API는 spec이기때문에 변경되면 안됨.
추 후 entity에 로직이 변경되었을때 API Spec도 변경되므로.